import logging
import json
from typing import *
from enum import Enum
from datetime import datetime
from utils import strings

logger = logging.getLogger('proact.database.mission')

class MissionStatus(Enum):
    NOT_STARTED = 'not started'
    IN_PROGRESS = 'in progress'
    DONE = 'done'
# end class

class MissionPeriodType(Enum):
    WEEK = 'weekly'
    '''Mission estimated to complete in 1 week.
    '''
    ONGOING = 'ongoing'
    '''Mission does not have a clear duration; deadline is flexible.
    '''
# end class

class Mission:
    '''Represents a single mission/task.

    Supports json serialize and parse.
    '''

    PERIOD_TYPE_DEFAULT = MissionPeriodType.ONGOING

    @classmethod
    def table_name(cls) -> str:
        return cls.__name__
    # end def

    def __init__(self, **kwargs):
        self.id: Optional[str] = kwargs.get('id', None)
        '''Unique mission id, generated by firebase.
        
        If not defined, assume this is in context of creating a new mission, for which the id is not
        get generated.
        '''
        _type = kwargs.get('type', self.PERIOD_TYPE_DEFAULT)
        self.type: MissionPeriodType = (
            _type 
            if type(_type) == MissionPeriodType else
            MissionPeriodType._value2member_map_[_type]
        )
        
        status = kwargs.get('status', MissionStatus.NOT_STARTED)
        self.status: MissionStatus = (
            status
            if type(status) == MissionStatus else
            MissionStatus._value2member_map_[status]
        )

        self.title: str = kwargs['title']
        self.description: Optional[str] = kwargs.get('description', None)

        steps: List[Union[str, Mission]] = kwargs.get('steps', [])
        self.steps_id: List[str] = []
        '''List of child mission ids.
        '''
        self.steps_mission: List[Mission] = []
        '''List of child missions.
        
        In context of querying a parent mission, this list will not be populated until `steps_id` is
        used to query child mission details.
        '''

        if len(steps) > 0:
            if type(steps[0]) == str:
                self.steps_id = [
                    step_id for step_id in steps
                ]
                # steps_mission can be optionally determined by query when needed

            else:
                for step_mission in steps:
                    self.steps_mission.append(step_mission)
                    self.steps_id.append(step_mission.id)
        # end if

        deadline: Optional[str] = kwargs.get('deadline', None)
        self.deadline: Optional[datetime] = None
        if deadline is not None:
            self.deadline = datetime.fromisoformat(deadline)
        # end if

        self.style_id: Optional[str] = kwargs.get('styleId', None)
        '''Reference to a `ComponentStyle`.
        '''
        self.event_id: Optional[str] = kwargs.get('eventId', None)
        '''Reference to an `Event`.
        '''
    # end def

    def __str__(self) -> str:
        return f'{type(self).__name__}[id={self.id} title="{self.title}"]'
    # end def

    @classmethod
    def from_dict(
        cls, 
        mission: Dict, 
        steps_are_raw=True, 
        title_word_limit: int = 25
    ) -> 'Mission':
        '''Parse mission data as a `Mission` instance.

        TODO derive step titles from raw descriptions using `GeminiClient`.

        :param steps_are_raw: Whether the child missions are provided as raw descriptions.
        '''

        logger.debug(f'create {cls.__name__} from {mission}')

        if steps_are_raw and 'steps' in mission:
            # convert step descriptions to Mission instances
            steps = []
            for step in mission['steps']:
                steps.append(Mission(
                    type=mission.get('type', cls.PERIOD_TYPE_DEFAULT),
                    title=' '.join(strings.to_words(step)[:title_word_limit]),
                    description=step,
                    steps=[],
                    deadline=mission.get('deadline')
                ))
            # end for step

            mission['steps'] = steps
        # end if steps raw

        return Mission(**mission)
    # end def

    def to_dict(self, depth: int=0) -> Dict:
        d = {
            'id': self.id,
            'type': self.type.value,
            'status': self.status.value,
            'title': self.title,
            'description': self.description,
            'steps': self.steps_id,
            'deadline': self.deadline,
            'styleId': self.style_id,
            'eventId': self.event_id
        }

        if depth > 0:
            d['steps'] = [
                step.to_dict(depth=depth-1)
                for step in self.steps_mission
            ]
        # end if depth

        return d
    # end def
# end class

class UserMission:
    '''Represents assignments of users to missions.

    Supports json serialize and parse.
    '''

    @classmethod
    def table_name(cls) -> str:
        return cls.__name__
    # end def

    def __init__(self, **kwargs):
        self.id: Optional[str] = kwargs.get('id', None)
        '''Unique user-mission id, generated by firebase.
        
        If not defined, assume this is in context of creating a new assignment, for which the id is not
        get generated.
        '''

        self.user_id: str = kwargs['userId']
        self.mission_id: str = kwargs['missionId']
    # end def

    def __str__(self) -> str:
        return f'{type(self).__name__}[id={self.id} user_id={self.user_id} mission_id={self.mission_id}]'
    # end def

    @classmethod
    def from_dict(cls, user_mission: Dict) -> 'UserMission':
        '''Parse user mission data as a `UserMission` instance.
        '''

        return UserMission(**user_mission)
    # end def

    def to_dict(self) -> Dict:
        return {
            'id': self.id,
            'userId': self.user_id,
            'missionId': self.mission_id
        }
    # end def
# end class
